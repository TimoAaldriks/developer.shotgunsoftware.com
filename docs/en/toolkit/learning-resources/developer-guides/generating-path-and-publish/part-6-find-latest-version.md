---
layout: default
title:  Part 6 Finding the latest version number
pagename: part-6-find-latest-version
lang: en
---

# Part 6 - Finding existing files and getting the latest version number

[Overview](./sgtk-developer-generating-path-and-publish.md)<br/>
[Previous step](./part-5-build-a-path.md)

There two methods you could use here. 

1. Since in this particular example you are resolving a publish file, you could use the Shotgun API to query for the
next available version number on `PublishedFile` entities.
2. You can scan the files on disk and work out what versions already exist, and extract the next version number. 
This is helpful if the files your working with aren't tracked in Shotgun (such as work files).

Whilst the first option would probably be most suitable for the example in this guide, both approaches have their uses so we'll cover them both.
Also if you had work files as well and only considered the publish 

## Querying Shotgun for the next version number.

Using the SG API and the [`summarize()` method](https://developer.shotgunsoftware.com/python-api/reference.html#shotgun_api3.shotgun.Shotgun.summarize) we can get the highest version number amongst 
the PublishedFiles with the same name on the task, and then add 1.

```python
def get_next_version_number(sg, task_id, file_name):
    # Run a Shotgun API query to summarize the maximum version number on PublishedFiles that
    # are linked to the task and match the provided name.
    # Since PublishedFiles generated by the Publish app have the extension on the end of the name we need to add the
    # extension in our filter.
    r = sg.summarize(entity_type="PublishedFile",
                 filters = [["task", "is", {"type":"Task", "id": task_id}],
                            ["name","is",file_name]],
                 summary_fields=[{"field":"version_number", "type":"maximum"}])

    # Extract the version number and add 1 to it.
    # In scenarios where there are no files already this summary will return 0.
    return r["summaries"]["version_number"] + 1
    
get_next_version_number(engine.shotgun, context.task["id"], "scene.ma")
```

## Searching the file system for the next version number.

Using the Toolkit API we can gather a list of existing files, extract the template field values from them,
and then figure out the next version. 

In the example bellow it's gathering the latest version from the workfiles template
assuming the workfiles and publish file templates have the same fields you could call this twice with the same fields
to work out the highest publish and workfile version and decide and decide using a combination of the two.

```python
def get_next_version_number(tk, template_name, fields):
    template_work = tk.templates[template_name]

    # Get a list of existing file paths on disk that match the template and provided fields
    # Skip the version field as we want to find all versions not a specific version.
    skip_fields = ["version"]
    work_file_paths = tk.paths_from_template(
                 template_work,
                 fields,
                 skip_fields,
                 skip_missing_optional_keys=True
             )

    versions = []
    for work_file in work_file_paths:
        # extract the values from the path so we can read the version.
        path_fields = template_work.get_fields(work_file)
        versions.append(path_fields["version"])
    
    # find the highest version in the list and add one.
    return max(versions) + 1

get_next_version_number(tk, "maya_shot_work", fields)
```

The [`sgtk.paths_from_template()`](https://developer.shotgunsoftware.com/tk-core/core.html?highlight=paths_from_template#sgtk.Sgtk.paths_from_template) method
will gather all the files on disk that match the provided template and fields. This is method is also useful for scenarios
where you want to find and display a list of files to the user. 

## Conclusion

Now you have the logic to figure out the latest version, you can remove the hardcoded version and replace it with this logic.

```python
import sgtk
import os

# Get the engine instance that is currently running.
current_engine = sgtk.platform.current_engine()

# Grab the pre created Sgtk instance from the current engine.
tk = current_engine.sgtk

# Get a context object from a Task, this Task must belong to a Shot for the future steps to work. 
context = tk.context_from_entity("Task", 13155)

# Create the required folders based upon the task.
tk.create_filesystem_structure("Task", context.task["id"])

# Get a template instance by providing a name of a valid template in your config's templates.yml.
template = tk.templates["maya_shot_publish"]

# Use the context to resolve as many of the template fields as possible.
fields = context.as_template_fields(template)

# Manually resolve the remaining fields that can't be figured out automatically from context.
fields["name"] = "myscene"

# Get an authenticated Shotgun API instance from the engine.
sg = current_engine.shotgun
# Run a Shotgun API query to summarize the maximum version number on PublishedFiles that
# are linked to the task and match the provided name.
# Since PublishedFiles generated by the Publish app have the extension on the end of the name we need to add the
# extension in our filter.
r = sg.summarize(entity_type="PublishedFile",
                 filters = [["task", "is", {"type":"Task", "id": context.task["id"]}],
                            ["name","is", fields["name"] + ".ma"]],
                 summary_fields=[{"field":"version_number", "type":"maximum"}])

# Extract the version number and add 1 to it.
# In scenarios where there are no files already this summary will return 0.
fields["version"] = r["summaries"]["version_number"] + 1

# Use the fields to resolve the template path into an absolute path.
publish_path = template.apply_fields(fields)

# Make sure we create any missing folders.
current_engine.ensure_folder_exists(os.path.dirname(publish_path))

# Create a empty file on disk. (optional - should be replaced by actual file save or copy logic)
sgtk.util.filesystem.touch_file(publish_path)
```

The next step is to [register the path as a published file](part-7-registering-publish.md).